import { Injectable, inject } from '@angular/core';
import { Observable, of, forkJoin } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { DatabaseService } from './database/database.service';
import { AuthService } from './auth.service';
import { ExerciseService } from './exercise.service';
import {
  ExerciseHistoryRecord,
  ExerciseHistoryStats,
  ActivityTimelineData,
  HistorySentenceAttempt,
  HistoryPenaltyMetrics
} from '../models/exercise-history.model';
import { SentenceProgress } from './exercise-state.service';

/**
 * Service for managing exercise history tracking
 * Records detailed attempt data and provides analytics
 */
@Injectable({
  providedIn: 'root'
})
export class ExerciseHistoryService {
  private databaseService = inject(DatabaseService);
  private authService = inject(AuthService);
  private exerciseService = inject(ExerciseService);

  // Cache for history data
  private historyCache: ExerciseHistoryRecord[] | null = null;
  private historyCacheTimestamp = 0;
  private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

  /**
   * Record a completed exercise attempt
   * Called from ExerciseDetailComponent after exercise completion
   */
  recordExerciseAttempt(
    exerciseId: string,
    finalScore: number,
    timeSpentSeconds: number,
    hintsUsed: number,
    sentences: SentenceProgress[],
    penaltyMetrics: { baseScore: number; totalIncorrectAttempts: number; totalRetries: number; totalPenalty: number }
  ): Observable<void> {
    const userId = this.authService.getUserId();
    if (!userId) {
      console.log('[ExerciseHistoryService] No userId, skipping record');
      return of(undefined);
    }

    // Transform SentenceProgress[] to HistorySentenceAttempt[]
    const sentenceAttempts: HistorySentenceAttempt[] = sentences.map((s, index) => ({
      sentenceIndex: index,
      originalText: s.original,
      userTranslation: s.translation,
      accuracyScore: s.accuracyScore || 0,
      retryCount: s.retryCount || 0,
      aiFeedback: s.suggestion
    }));

    const historyPenaltyMetrics: HistoryPenaltyMetrics = {
      baseScore: penaltyMetrics.baseScore,
      totalIncorrectAttempts: penaltyMetrics.totalIncorrectAttempts,
      totalRetries: penaltyMetrics.totalRetries,
      totalPenalty: penaltyMetrics.totalPenalty,
      finalScore
    };

    const record: ExerciseHistoryRecord = {
      id: '', // Will be generated by database
      userId,
      exerciseId,
      completedAt: new Date(),
      finalScore,
      timeSpentSeconds,
      hintsUsed,
      sentenceAttempts,
      penaltyMetrics: historyPenaltyMetrics,
      createdAt: new Date()
    };

    return this.databaseService.insertExerciseHistory(record).pipe(
      map(() => {
        // Invalidate cache after recording new attempt
        this.invalidateCache();
        return undefined;
      }),
      catchError(error => {
        console.error('[ExerciseHistoryService] Failed to record attempt:', error);
        // Don't throw - history recording should not block exercise completion
        return of(undefined);
      })
    );
  }

  /**
   * Get recent exercise history (last N attempts)
   * Uses cache if available to avoid duplicate requests
   */
  getRecentHistory(limit: number = 10): Observable<ExerciseHistoryRecord[]> {
    const userId = this.authService.getUserId();
    if (!userId) {
      return of([]);
    }

    // If cache is valid and has enough data, use it
    if (this.isCacheValid() && this.historyCache && this.historyCache.length >= limit) {
      console.log('[ExerciseHistoryService] Using cached history');
      return of(this.historyCache.slice(0, limit));
    }

    return this.databaseService.loadRecentHistory(userId, limit).pipe(
      map(records => {
        // Update cache if we got more data
        if (!this.historyCache || records.length > this.historyCache.length) {
          this.historyCache = records;
          this.historyCacheTimestamp = Date.now();
        }
        return records;
      }),
      catchError(error => {
        console.error('[ExerciseHistoryService] Failed to load recent history:', error);
        return of([]);
      })
    );
  }

  /**
   * Check if cache is still valid
   */
  private isCacheValid(): boolean {
    return this.historyCacheTimestamp > 0 && 
           (Date.now() - this.historyCacheTimestamp) < this.CACHE_DURATION;
  }

  /**
   * Invalidate cache (call after recording new attempt)
   */
  invalidateCache(): void {
    this.historyCache = null;
    this.historyCacheTimestamp = 0;
  }

  /**
   * Get statistics from exercise history
   * Uses cache if available
   */
  getStatistics(): Observable<ExerciseHistoryStats> {
    const userId = this.authService.getUserId();
    if (!userId) {
      return of(this.getEmptyStats());
    }

    // Use cache if valid and has substantial data
    if (this.isCacheValid() && this.historyCache && this.historyCache.length > 0) {
      console.log('[ExerciseHistoryService] Using cached history for statistics');
      return of(this.calculateStatistics(this.historyCache));
    }

    return this.databaseService.loadRecentHistory(userId, 1000).pipe(
      map(records => {
        // Update cache with full data
        this.historyCache = records;
        this.historyCacheTimestamp = Date.now();
        return this.calculateStatistics(records);
      }),
      catchError(error => {
        console.error('[ExerciseHistoryService] Failed to load statistics:', error);
        return of(this.getEmptyStats());
      })
    );
  }

  /**
   * Get activity timeline for a date range
   */
  getActivityTimeline(startDate: Date, endDate: Date): Observable<ActivityTimelineData[]> {
    const userId = this.authService.getUserId();
    if (!userId) {
      return of([]);
    }

    return this.databaseService.loadHistoryForDateRange(userId, startDate, endDate).pipe(
      map(records => this.groupByDate(records)),
      catchError(error => {
        console.error('[ExerciseHistoryService] Failed to load activity timeline:', error);
        return of([]);
      })
    );
  }

  /**
   * Get history for a specific exercise
   */
  getExerciseHistory(exerciseId: string): Observable<ExerciseHistoryRecord[]> {
    const userId = this.authService.getUserId();
    if (!userId) {
      return of([]);
    }

    return this.databaseService.loadExerciseHistory(userId, exerciseId).pipe(
      catchError(error => {
        console.error('[ExerciseHistoryService] Failed to load exercise history:', error);
        return of([]);
      })
    );
  }

  /**
   * Calculate statistics from history records
   */
  private calculateStatistics(records: ExerciseHistoryRecord[]): ExerciseHistoryStats {
    if (records.length === 0) {
      return this.getEmptyStats();
    }

    const totalExercisesCompleted = records.length;
    const averageAccuracy = records.reduce((sum, r) => sum + r.finalScore, 0) / totalExercisesCompleted;
    const totalTimeSpentMinutes = records.reduce((sum, r) => sum + r.timeSpentSeconds, 0) / 60;
    const averageTimePerExercise = totalTimeSpentMinutes / totalExercisesCompleted;

    // Get best performances (top 5 by score)
    const sortedByScore = [...records].sort((a, b) => b.finalScore - a.finalScore);
    const bestPerformances = sortedByScore.slice(0, 5).map(r => ({
      exerciseId: r.exerciseId,
      exerciseTitle: this.getExerciseTitle(r.exerciseId),
      score: r.finalScore,
      completedAt: r.completedAt
    }));

    // Get most practiced (top 5 by attempt count)
    const exerciseCounts = new Map<string, number>();
    records.forEach(r => {
      exerciseCounts.set(r.exerciseId, (exerciseCounts.get(r.exerciseId) || 0) + 1);
    });

    const mostPracticed = Array.from(exerciseCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([exerciseId, attemptCount]) => ({
        exerciseId,
        exerciseTitle: this.getExerciseTitle(exerciseId),
        attemptCount
      }));

    return {
      totalExercisesCompleted,
      averageAccuracy: Math.round(averageAccuracy),
      totalTimeSpentMinutes: Math.round(totalTimeSpentMinutes),
      averageTimePerExercise: Math.round(averageTimePerExercise),
      bestPerformances,
      mostPracticed
    };
  }

  /**
   * Group history records by date
   */
  private groupByDate(records: ExerciseHistoryRecord[]): ActivityTimelineData[] {
    const dateMap = new Map<string, number>();

    records.forEach(r => {
      const dateStr = r.completedAt.toISOString().split('T')[0]; // YYYY-MM-DD
      dateMap.set(dateStr, (dateMap.get(dateStr) || 0) + 1);
    });

    return Array.from(dateMap.entries())
      .map(([date, completionCount]) => ({ date, completionCount }))
      .sort((a, b) => a.date.localeCompare(b.date));
  }

  /**
   * Get exercise title by ID
   * Returns exerciseId as fallback since we can't synchronously get the title
   */
  private getExerciseTitle(exerciseId: string): string {
    // For now, return exerciseId as title
    // In a real implementation, we could cache exercise titles or fetch them
    return exerciseId;
  }

  /**
   * Get empty statistics object
   */
  private getEmptyStats(): ExerciseHistoryStats {
    return {
      totalExercisesCompleted: 0,
      averageAccuracy: 0,
      totalTimeSpentMinutes: 0,
      averageTimePerExercise: 0,
      bestPerformances: [],
      mostPracticed: []
    };
  }
}
